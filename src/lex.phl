module lex;

import phl::lang::collections;
import err;

/* erota sanat toisistaan */
@String[] lex(@String code) [
	var a = new @String[];
	
	var currWord = "";
	
	var len = code::len;
	for (var i = 0; i < len; i=i+1) {
		var ch = code[i];
		
		if (ch == ' ' || ch == '\t') {
			if (currWord::len > 0) a.add(currWord);
			currWord = "";
		} else if (ch == '#' || ch == ':' || ch == ',' || ch == '(' || ch == ')') {
			if (currWord::len > 0) a.add(currWord);
			currWord = "";
			a.add("".appendch(ch));
		} else if (ch == '\n') {
			if (currWord::len > 0) a.add(currWord);
			currWord = "";
			a.add("(NL)");
		} else if (ch == '"') { /* '"' */
			if (currWord::len > 0) a.add(currWord); currWord = "";
			
			i = i + 1;
			while (code[i] != '"') /* '"' */ {
				a.add(@String code[i]);
				i = i + 1;
			}
		} else if (ch == '\\') {
			if (currWord::len > 0) a.add(currWord);
			currWord = "";
			i = i + 1;
			a.add("".appendch(code[i]));
		} else if (ch == ';') {
			if (currWord::len > 0) a.add(currWord);
			currWord = "";
			do { i=i+1; ch = code[i]; } while (ch != '\n');
		} else {
			currWord = currWord.appendch(ch);
		}
	}
	
	if (currWord::len > 0) a.add(currWord);
	currWord = "";
	
	return preprocess(a);
]

/* Yksinkertainen esik채채nt채j채 */

struct @PPMacro {
	field @String[] params;
	field @String[] body;
	
	@PPMacro init(@String[] params, @String[] body) [
		this::params = params;
		this::body = body;
		return this;
	]
	
	@String[] eval(@String[][] args) [
		if (null != this::params) {
			/*if (args::size != this::params::size) err("wrong number of macro parameters");*/
			
			var tmp = macros;
			macros = new @PPScope.init(null);
		
			args iterate #(i, arg) [
				macros::macros[this::params[i]] = new @PPMacro.init(null, arg);
			];
		
			var a = preprocess(new @String[].addAll(this::body));
			macros = tmp;
			return a;
		}
		
		return this::body;
	]
	
	auto @String [
		if (null != params())
			return "" + params() + "" + body();
		else return "[]" + body();
	]
};

struct @PPScope {
	field @PPScope super_;
	field @Hashtable<@PPMacro> macros;
	
	new [ this::macros = new @Hashtable<@PPMacro>; ]
	
	@PPScope init(@PPScope super_) [
		this::super_ = super_;
		return this;
	]
	
	@PPMacro getMacro(@String name) [
		var macro = this::macros[name];
		if (null != macro) return macro;
		else if (null != super_()) return super_().getMacro(name);
		else return null;
	]
};

static @PPScope macros;

@String[] preprocess(@String[] a) [
	if (null == macros) macros = new @PPScope.init(null);
	
	var asize = a::size;
	
	var print = true; var ifdepth = 0;
	
	for (var i = 0; i < asize; i=i+1) {
		doc printf("%s\n", @String a);
		if (print::n) {
			if (i+1 >= asize) err("directive syntax error");
			if (a[i] == "#" && a[i+1] == "ifdef" || a[i+1] == "ifndef") {
				ifdepth = ifdepth + 1;
			}
			if (a[i] == "#" && a[i+1] == "endif") {
				if (ifdepth == 1) {
					print = true;
					a.remove(i);
				}
				else ifdepth = ifdepth - 1;
			}
			a.remove(i);
			
			i = i - 1;
			asize = a::size;
		}
		else if (a[i] == "#") {
			a.remove(i);
			if (i == asize-1) err("directive syntax error");
			var directive = a.remove(i);
			if (directive == "define") {
				if (i == asize-2) err("directive:define syntax error");
				var macro_name = a.remove(i);
				var macro_params = @String[] null;
				if (i == asize-3) err("directive:define syntax error");
				if (a[i] == "(") {
					macro_params = new @String[];
					if (i == a::size) err("directive:define syntax error");
					while (a.remove(i) != ")") {
						if (i == a::size) err("directive:define syntax error");
						macro_params.add("p#"+a.remove(i));
					}
				}
				var macro_body = new @String[];
				if (i == a::size) err("directive:define syntax error");
				while (a[i] != "(NL)") {
					if (i == a::size) err("directive:define syntax error");
					if (macro_params!=null)
						if (macro_params.contains("p#"+a[i])) macro_body.add("p#" + a.remove(i));
						else macro_body.add(a.remove(i));
					else macro_body.add(a.remove(i));
				}
				if (i == a::size) err("directive:define syntax error");
				a.remove(i);
				macros::macros[macro_name] = new @PPMacro.init(macro_params, macro_body);
			}
			else if (directive == "undefine") {
				if (i == asize-2) err("directive:undefine syntax error");
				var macro_name = a.remove(i);
				macros::macros[macro_name] = null;
			}
			else if (directive == "ifdef") {
				if (i == asize-2) err("directive:ifdef syntax error");
				var macro_name = a.remove(i);
				if (macros::macros[macro_name] == null) print = false;
				ifdepth = 1;
			}
			else if (directive == "ifndef") {
				if (i == asize-2) err("directive:ifndef syntax error");
				var macro_name = a.remove(i);
				if (macros::macros[macro_name] != null) print = false;
				ifdepth = 1;
			}
			else if (directive == "endif") {
				if (i == asize-2) err("directive:ifndef syntax error");
				var macro_name = a.remove(i);
				if (macros::macros[macro_name] != null) print = false;
				ifdepth = 0;
			}
			else err("unknown directive '" + directive + "'");
			i = i - 1;
			asize = a::size;
		} else if (a[i] == ":") {
			a.remove(i);
			var macro_name = a.remove(i);
			var macro_body = new @String[];
			macro_body.add(""+i);
			macros::macros[macro_name] = new @PPMacro.init(null, macro_body);
			i = i - 1;
			asize = a::size;
		} else if (a[i] == "(NL)") {
			a.remove(i);
			i = i - 1;
			asize = a::size;
		} else {
			var macro = macros.getMacro(a[i]);
			if (null != macro) {
				doc printf("found macro: %s %s\n", a[i], @String macro);
				a.remove(i);
				if (i < asize-1) {
					if (a[i] == "(" && null != macro::params) {
						a.remove(i);
						var macro_args = new @String[][];
					
						if (i == asize-2) err("macro syntax error");
						while (true) {
							var arg = new @String[];
							macro_args.add(arg);
							var depth = 0;
							if (i == a::size) err("macro syntax error");
							while (((a[i] == "," || a[i] == ")") && depth <= 0)::n) {
								var c = a[i];
								if (c == "(") depth = depth + 1;
								else if (c == ")") depth = depth - 1;
								a.remove(i);
								if (i == a::size) err("macro syntax error");
								arg.add(c);
							}
							
							if (a.remove(i) == ")") break;
						}
						a.insertAll(i, macro.eval(macro_args));
					} else {
						a.insertAll(i, macro.eval(null));
					}
				}
				else {
					a.insertAll(i, macro.eval(null));
				}
				i = i - 1;
				asize = a::size;
			}
		}
	}
	for (var i = 0; i < asize; i=i+1) {
		var macro = macros.getMacro(a[i]);
		if (null != macro) {
			a.remove(i);
			if (i < asize-1) {
				if (a[i] == "(" && null != macro::params) {
					a.remove(i);
					var macro_args = new @String[][];
				
					if (i == asize-2) err("macro syntax error");
					while (true) {
						var arg = new @String[];
						macro_args.add(arg);
						var depth = 0;
						if (i == a::size) err("macro syntax error");
						while (((a[i] == "," || a[i] == ")") && depth <= 0)::n) {
							var c = a[i];
							if (c == "(") depth = depth + 1;
							else if (c == ")") depth = depth - 1;
							a.remove(i);
							if (i == a::size) err("macro syntax error");
							arg.add(c);
						}
					
						if (a.remove(i) == ")") break;
					}
					a.insertAll(i, macro.eval(macro_args));
				} else {
					a.insertAll(i, macro.eval(null));
				}
			}
			else {
				a.insertAll(i, macro.eval(null));
			}
			i = i - 1;
			asize = a::size;
		}
	}
	return a;
]
